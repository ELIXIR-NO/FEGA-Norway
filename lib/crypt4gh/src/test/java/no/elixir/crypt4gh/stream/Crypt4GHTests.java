package no.elixir.crypt4gh.stream;

import static no.elixir.crypt4gh.pojo.body.Segment.UNENCRYPTED_DATA_SEGMENT_SIZE;
import static org.junit.jupiter.api.Assertions.*;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.util.List;
import java.util.Objects;
import no.elixir.crypt4gh.pojo.header.DataEditList;
import no.elixir.crypt4gh.pojo.header.Header;
import no.elixir.crypt4gh.util.Crypt4GHUtils;
import no.elixir.crypt4gh.util.KeyUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.junit.jupiter.api.Test;

/**
 * A bunch of tests for Crypt4GH Input/Output streams with or without skip-access and DataEditLists.
 */
public class Crypt4GHTests {

  private KeyUtils keyUtils = KeyUtils.getInstance();
  private Crypt4GHUtils crypt4GHUtils = Crypt4GHUtils.getInstance();

  /**
   * Tests re-encryption of a byte-array generated in memory with Crypt4GH keys
   * (https://crypt4gh.readthedocs.io/en/latest/keys.html).
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void memoryReencryptionCrypt4GHKeys() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec"))
                    .getFile()),
            "asdf".toCharArray());
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec"))
                    .getFile()),
            "password".toCharArray());
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub"))
                    .getFile()));

    byte[] unencryptedData = new byte[1024 * 1024];
    SecureRandom.getInstanceStrong().nextBytes(unencryptedData);

    try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(byteArrayOutputStream, writerPrivateKey, readerPublicKey)) {
        crypt4GHOutputStream.write(unencryptedData);
      }
      byte[] encryptedData = byteArrayOutputStream.toByteArray();
      try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(encryptedData);
          Crypt4GHInputStream crypt4GHInputStream =
              new Crypt4GHInputStream(byteArrayInputStream, readerPrivateKey)) {
        byte[] decryptedData = crypt4GHInputStream.readAllBytes();
        assertArrayEquals(unencryptedData, decryptedData);
      }
    }
  }

  /**
   * Tests re-encryption of a byte-array generated in memory with OpenSSL keys.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void memoryReencryptionOpenSSLKeys() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));

    byte[] unencryptedData = new byte[1024 * 1024];
    SecureRandom.getInstanceStrong().nextBytes(unencryptedData);

    try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(byteArrayOutputStream, writerPrivateKey, readerPublicKey)) {
        crypt4GHOutputStream.write(unencryptedData);
      }
      byte[] encryptedData = byteArrayOutputStream.toByteArray();
      try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(encryptedData);
          Crypt4GHInputStream crypt4GHInputStream =
              new Crypt4GHInputStream(byteArrayInputStream, readerPrivateKey)) {
        byte[] decryptedData = crypt4GHInputStream.readAllBytes();
        assertArrayEquals(unencryptedData, decryptedData);
      }
    }
  }

  /**
   * Tests re-encryption of a byte-array generated in memory with keys generated by the library
   * itself.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void memoryReencryptionOwnKeys() throws Exception {
    PrivateKey writerPrivateKey = keyUtils.generatePrivateKey();
    KeyPair readerKeyPair = keyUtils.generateKeyPair();
    PrivateKey readerPrivateKey = readerKeyPair.getPrivate();
    PublicKey readerPublicKey = readerKeyPair.getPublic();

    byte[] unencryptedData = new byte[1024 * 1024];
    SecureRandom.getInstanceStrong().nextBytes(unencryptedData);

    try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(byteArrayOutputStream, writerPrivateKey, readerPublicKey)) {
        crypt4GHOutputStream.write(unencryptedData);
      }
      byte[] encryptedData = byteArrayOutputStream.toByteArray();
      try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(encryptedData);
          Crypt4GHInputStream crypt4GHInputStream =
              new Crypt4GHInputStream(byteArrayInputStream, readerPrivateKey)) {
        byte[] decryptedData = crypt4GHInputStream.readAllBytes();
        assertArrayEquals(unencryptedData, decryptedData);
      }
    }
  }

  /**
   * Tests re-encryption of a file on a file-system.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void fileReencryptionTest() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));

    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    File decryptedFile = Files.createTempFile("test", "dec").toFile();
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
      }
    }
    try (FileInputStream inputStream = new FileInputStream(encryptedFile);
        FileOutputStream outputStream = new FileOutputStream(decryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(inputStream, readerPrivateKey)) {
      IOUtils.copy(crypt4GHInputStream, outputStream);
      assertEquals(
          FileUtils.readFileToString(unencryptedFile, Charset.defaultCharset()),
          FileUtils.readFileToString(decryptedFile, Charset.defaultCharset()));
    } finally {
      encryptedFile.delete();
      decryptedFile.delete();
    }
  }

  /**
   * Tests re-encryption of a file on a file-system with skipping forward to some specified byte.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void partialFileReencryptionTest() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));

    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
      }
    }
    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, readerPrivateKey);
        FileInputStream unencryptedInputStream = new FileInputStream(unencryptedFile)) {
      unencryptedInputStream.skip(UNENCRYPTED_DATA_SEGMENT_SIZE + 100);
      crypt4GHInputStream.skip(UNENCRYPTED_DATA_SEGMENT_SIZE + 100);
      assertArrayEquals(unencryptedInputStream.readAllBytes(), crypt4GHInputStream.readAllBytes());
    } finally {
      encryptedFile.delete();
    }
  }

  /**
   * Tests re-encryption of a file on a file-system with DataEditList.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void fileReencryptionWithDataEditListTest() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));

    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
      }
    }
    DataEditList dataEditList = new DataEditList(new long[] {950, 837, 510, 847});
    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, dataEditList, readerPrivateKey);
        FileInputStream unencryptedInputStream = new FileInputStream(unencryptedFile)) {
      List<String> lines = IOUtils.readLines(crypt4GHInputStream, Charset.defaultCharset());
      assertNotNull(lines);
      assertEquals(2, lines.size());
      unencryptedInputStream.skip(950);
      String firstLine = new String(unencryptedInputStream.readNBytes(837)).trim();
      assertEquals(firstLine, lines.get(0));
      unencryptedInputStream.skip(510);
      String secondLine = new String(unencryptedInputStream.readNBytes(847)).trim();
      assertEquals(secondLine, lines.get(1));
    } finally {
      encryptedFile.delete();
    }
  }

  /**
   * Tests re-encryption of a file on a file-system with DataEditList. The edit list here has an odd
   * number of values, which means that the final value is a segment to exclude. According to the
   * specification, the rest of the file after this excluded segment should then be included.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void fileReencryptionWithOddValuedDataEditListTest() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));

    // Preparing the full sample unencrypted file which selected data/lines will be extracted from
    // by using a DataEditList
    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    // Encrypting the full sample file into the test.enc file
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
      }
    }
    // The odd-numbered DataEditList to be tested for extracting two data segments/lines from the
    // sample.txt file (2nd and 4th number of bytes) plus the rest of the file/lines after
    // the last excluded number of bytes (5th number). These edit values will cut out lines 1-2,
    // keep line 3, cut lines 4-6, keep line 7, cut lines 8-10 and implicitly keep lines 11-225.
    DataEditList dataEditList = new DataEditList(new long[] {950, 837, 510, 847, 363});
    // 1. Setup the crypt4GHInputStream with the dataEditList
    // 2. Read in all lines of crypt4GHInputStream, returning the unencrypted results after
    //    dataEditList has been applied. This should be 1+1+215=217 lines.
    // 3. Manually traverse the raw unencryptedInputStream with the same steps of bytes and
    //    extracted number of bytes as specified in the dataEditList
    // 4. Assert that the results from step 2 and 3 match for each of the three extracted parts
    //    (line 3, line 7 and lines 11-225)
    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, dataEditList, readerPrivateKey);
        FileInputStream unencryptedInputStream = new FileInputStream(unencryptedFile)) {
      List<String> lines = IOUtils.readLines(crypt4GHInputStream, Charset.defaultCharset());
      assertNotNull(lines);
      assertEquals(217, lines.size());
      unencryptedInputStream.skip(950);
      String firstLine = new String(unencryptedInputStream.readNBytes(837)).trim();
      assertEquals(firstLine, lines.get(0));
      unencryptedInputStream.skip(510);
      String secondLine = new String(unencryptedInputStream.readNBytes(847)).trim();
      assertEquals(secondLine, lines.get(1));
      unencryptedInputStream.skip(363);
      String remainingLines = new String(unencryptedInputStream.readNBytes(66718)).trim();
      String[] remainingLinesArray = remainingLines.lines().toArray(String[]::new);
      for (int i = 0; i < 215; i++) {
        assertEquals(remainingLinesArray[i], lines.get(2 + i));
      }
    } finally {
      encryptedFile.delete();
    }
  }

  /**
   * Tests re-encryption of a file on a file-system with DataEditList injected to OutputStream and
   * skipping forward to some specified byte.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void partialFileReencryptionWithDataEditListInOutputStreamTest() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));

    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    DataEditList dataEditList = new DataEditList(new long[] {950, 837, 510, 847});
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, dataEditList, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
      }
    }

    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, readerPrivateKey);
        FileInputStream unencryptedInputStream = new FileInputStream(unencryptedFile)) {
      crypt4GHInputStream.skip(840);
      List<String> lines = IOUtils.readLines(crypt4GHInputStream, Charset.defaultCharset());
      assertNotNull(lines);
      assertEquals(1, lines.size());
      unencryptedInputStream.skip(950 + 837 + 510 + 3);
      String line = new String(unencryptedInputStream.readNBytes(843)).trim();
      assertEquals(line, lines.get(0));
    } finally {
      encryptedFile.delete();
    }
  }

  /**
   * Tests re-encryption of a file on a file-system with DataEditList injected to OutputStream and
   * forward skipping. The edit list has an odd number of values, so the rest of the file after the
   * final excluded segment should implicitly be included. The second forward skip lands within this
   * implicitly included segment.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void partialFileReencryptionWithOddValuedDataEditListInOutputStreamTest()
      throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));

    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    DataEditList dataEditList = new DataEditList(new long[] {950, 837, 510, 847, 3000});
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, dataEditList, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
      }
    }

    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, readerPrivateKey);
        FileInputStream unencryptedInputStream = new FileInputStream(unencryptedFile)) {
      unencryptedInputStream.skip(950 + 837 + 510 + 13);
      crypt4GHInputStream.skip(850);
      String unencryptedData = new String(unencryptedInputStream.readNBytes(700));
      String decryptedData = new String(crypt4GHInputStream.readNBytes(700));
      assertEquals(unencryptedData, decryptedData);
      unencryptedInputStream.skip(134 + 3000 + 4866);
      crypt4GHInputStream.skip(5000);
      unencryptedData = new String(unencryptedInputStream.readNBytes(59215));
      decryptedData = new String(crypt4GHInputStream.readNBytes(59215));
      assertEquals(unencryptedData, decryptedData);
    } finally {
      encryptedFile.delete();
    }
  }

  /**
   * Tests re-encryption of a file on a file-system with DataEditList applied to InputStream and
   * skipping forward to some specified byte.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void partialFileReencryptionWithDataEditListInInputStreamTest() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));

    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
      }
    }
    DataEditList dataEditList = new DataEditList(new long[] {950, 837, 510, 847});
    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, dataEditList, readerPrivateKey);
        FileInputStream unencryptedInputStream = new FileInputStream(unencryptedFile)) {
      crypt4GHInputStream.skip(840);
      List<String> lines = IOUtils.readLines(crypt4GHInputStream, Charset.defaultCharset());
      assertNotNull(lines);
      assertEquals(1, lines.size());
      unencryptedInputStream.skip(950 + 837 + 510 + 3);
      String line = new String(unencryptedInputStream.readNBytes(843)).trim();
      assertEquals(line, lines.get(0));
    } finally {
      encryptedFile.delete();
    }
  }

  /**
   * Tests setting recipient to a header.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void setRecipientToHeaderTest() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));
    KeyPair anotherReaderKeyPair = keyUtils.generateKeyPair();

    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    File encryptedFileWithAddedRecipient = Files.createTempFile("test2", "enc").toFile();
    DataEditList dataEditList = new DataEditList(new long[] {950, 837, 510, 847});
    Header header;
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, dataEditList, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
        header = crypt4GHOutputStream.getHeader();
      }
    }

    int headerLength = header.serialize().length;
    header =
        crypt4GHUtils.setRecipient(
            header.serialize(), readerPrivateKey, anotherReaderKeyPair.getPublic());
    assertEquals(2, header.getHeaderPackets().size());

    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        FileOutputStream encryptedOutputStream =
            new FileOutputStream(encryptedFileWithAddedRecipient)) {
      encryptedOutputStream.write(header.serialize());
      encryptedInputStream.skip(headerLength);
      IOUtils.copyLarge(encryptedInputStream, encryptedOutputStream);
    }

    try (FileInputStream encryptedInputStream =
            new FileInputStream(encryptedFileWithAddedRecipient);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, anotherReaderKeyPair.getPrivate());
        FileInputStream unencryptedInputStream = new FileInputStream(unencryptedFile)) {
      crypt4GHInputStream.skip(840);
      List<String> lines = IOUtils.readLines(crypt4GHInputStream, Charset.defaultCharset());
      assertNotNull(lines);
      assertEquals(1, lines.size());
      unencryptedInputStream.skip(950 + 837 + 510 + 3);
      String line = new String(unencryptedInputStream.readNBytes(843)).trim();
      assertEquals(line, lines.get(0));
    } finally {
      encryptedFile.delete();
      encryptedFileWithAddedRecipient.delete();
    }
  }

  /**
   * Tests adding recipient to a header.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void addRecipientToHeaderTest() throws Exception {
    PrivateKey writerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("writer.sec.pem"))
                    .getFile()),
            null);
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    PublicKey readerPublicKey =
        keyUtils.readPublicKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.pub.pem"))
                    .getFile()));
    KeyPair anotherReaderKeyPair = keyUtils.generateKeyPair();

    File unencryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("sample.txt"))
                .getFile());
    File encryptedFile = Files.createTempFile("test", "enc").toFile();
    File encryptedFileWithAddedRecipient = Files.createTempFile("test2", "enc").toFile();
    DataEditList dataEditList = new DataEditList(new long[] {950, 837, 510, 847});
    Header header;
    try (FileInputStream inputStream = new FileInputStream(unencryptedFile);
        FileOutputStream outputStream = new FileOutputStream(encryptedFile)) {
      try (Crypt4GHOutputStream crypt4GHOutputStream =
          new Crypt4GHOutputStream(outputStream, dataEditList, writerPrivateKey, readerPublicKey)) {
        IOUtils.copy(inputStream, crypt4GHOutputStream);
        header = crypt4GHOutputStream.getHeader();
      }
    }

    int headerLength = header.serialize().length;
    header =
        crypt4GHUtils.addRecipient(
            header.serialize(), readerPrivateKey, anotherReaderKeyPair.getPublic());
    assertEquals(4, header.getHeaderPackets().size());

    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        FileOutputStream encryptedOutputStream =
            new FileOutputStream(encryptedFileWithAddedRecipient)) {
      encryptedOutputStream.write(header.serialize());
      encryptedInputStream.skip(headerLength);
      IOUtils.copyLarge(encryptedInputStream, encryptedOutputStream);
    }

    try (FileInputStream encryptedInputStream =
            new FileInputStream(encryptedFileWithAddedRecipient);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, anotherReaderKeyPair.getPrivate());
        FileInputStream unencryptedInputStream = new FileInputStream(unencryptedFile)) {
      crypt4GHInputStream.skip(840);
      List<String> lines = IOUtils.readLines(crypt4GHInputStream, Charset.defaultCharset());
      assertNotNull(lines);
      assertEquals(1, lines.size());
      unencryptedInputStream.skip(950 + 837 + 510 + 3);
      String line = new String(unencryptedInputStream.readNBytes(843)).trim();
      assertEquals(line, lines.get(0));
    } finally {
      encryptedFile.delete();
      encryptedFileWithAddedRecipient.delete();
    }
  }

  /**
   * Tests decryption of empty content created by the <a
   * href="https://github.com/neicnordic/crypt4gh">Go implementation</a> of `crypt4gh` and OpenSSL
   * keys.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void decryptEmptyContentFromGoImplementationTest() throws Exception {
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec.pem"))
                    .getFile()),
            null);
    File encryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("empty.go.txt.c4gh"))
                .getFile());
    File decryptedFile = Files.createTempFile("test", "dec").toFile();
    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, readerPrivateKey);
        FileOutputStream decryptedOutputStream = new FileOutputStream(decryptedFile)) {

      IOUtils.copy(crypt4GHInputStream, decryptedOutputStream);
      assertEquals(0, decryptedFile.length());
    }
  }

  /**
   * Tests decryption of empty content created by the <a
   * href="https://github.com/CSCfi/crypt4gh-gui">Python GUI implementation</a> of `crypt4gh` and
   * Crypt4GH keys.
   *
   * @throws Exception In case something fails.
   */
  @Test
  public void decryptEmptyContentFromPythonImplementationTest() throws Exception {
    PrivateKey readerPrivateKey =
        keyUtils.readPrivateKey(
            new File(
                Objects.requireNonNull(getClass().getClassLoader().getResource("reader.sec"))
                    .getFile()),
            "password".toCharArray());
    File encryptedFile =
        new File(
            Objects.requireNonNull(getClass().getClassLoader().getResource("empty.python.txt.c4gh"))
                .getFile());
    File decryptedFile = Files.createTempFile("test", "dec").toFile();
    try (FileInputStream encryptedInputStream = new FileInputStream(encryptedFile);
        Crypt4GHInputStream crypt4GHInputStream =
            new Crypt4GHInputStream(encryptedInputStream, readerPrivateKey);
        FileOutputStream decryptedOutputStream = new FileOutputStream(decryptedFile)) {

      IOUtils.copy(crypt4GHInputStream, decryptedOutputStream);
      assertEquals(0, decryptedFile.length());
    }
  }
}
